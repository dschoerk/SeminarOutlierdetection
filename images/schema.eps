%!PS-Adobe-2.0 EPSF-2.0
%%BoundingBox: 74 560 387 684
%%HiResBoundingBox: 74.9758 560.913 386.365 683.934
%%Creator: dvips(k) 5.92b Copyright 2002 Radical Eye Software
%%Title: img.dvi
%%DocumentFonts: CMR12
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips -E -P pdf img.dvi -o img.ps
%DVIPSParameters: dpi=8000, compressed
%DVIPSSource:  TeX output 2004.06.30:1324
%%BeginProcSet: tex.pro
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/p{show}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0 N/Ry 0 N/V{}B/RV/v{
/Ry X/Rx X V}B statusdict begin/product where{pop false[(Display)(NeXT)
(LaserWriter 16/600)]{A length product length le{A length product exch 0
exch getinterval eq{pop true exit}if}{pop}ifelse}forall}{false}ifelse
end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{BDot}imagemask
grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat{BDot}
imagemask grestore}}ifelse B/QV{gsave newpath transform round exch round
exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0 rlineto
fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B/M{S p
delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}B/g{0 M}
B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p -3 w}B/n{
p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{0 S
rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: alt-rule.pro
%!
% Patch by TVZ
% Makes dvips files draw rules with stroke rather than fill.
% Makes narrow rules more predictable at low resolutions
% after distilling to PDF.
% May have unknown consequences for very thick rules.
% Tested only with dvips 5.85(k).
TeXDict begin
/QV {
  gsave newpath /ruleY X /ruleX X
  Rx Ry gt
  { ruleX ruleY Ry 2 div sub moveto Rx 0 rlineto Ry }
  { ruleX Rx 2 div add ruleY moveto 0 Ry neg rlineto Rx }
  ifelse
  setlinewidth 0 setlinecap stroke grestore
} bind def
end

%%EndProcSet
%%BeginProcSet: texc.pro
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/id 0 N/rw 0 N/rc 0 N/gp 0 N/cp 0 N/G 0 N/CharBuilder{save 3
1 roll S A/base get 2 index get S/BitMaps get S get/Cd X pop/ctr 0 N Cdx
0 Cx Cy Ch sub Cx Cw add Cy setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx
sub Cy .1 sub]/id Ci N/rw Cw 7 add 8 idiv string N/rc 0 N/gp 0 N/cp 0 N{
rc 0 ne{rc 1 sub/rc X rw}{G}ifelse}imagemask restore}B/G{{id gp get/gp
gp 1 add N A 18 mod S 18 idiv pl S get exec}loop}B/adv{cp add/cp X}B
/chg{rw cp id gp 4 index getinterval putinterval A gp add/gp X adv}B/nd{
/cp 0 N rw exit}B/lsh{rw cp 2 copy get A 0 eq{pop 1}{A 255 eq{pop 254}{
A A add 255 and S 1 and or}ifelse}ifelse put 1 adv}B/rsh{rw cp 2 copy
get A 0 eq{pop 128}{A 255 eq{pop 127}{A 2 idiv S 128 and or}ifelse}
ifelse put 1 adv}B/clr{rw cp 2 index string putinterval adv}B/set{rw cp
fillstr 0 4 index getinterval putinterval adv}B/fillstr 18 string 0 1 17
{2 copy 255 put pop}for N/pl[{adv 1 chg}{adv 1 chg nd}{1 add chg}{1 add
chg nd}{adv lsh}{adv lsh nd}{adv rsh}{adv rsh nd}{1 add adv}{/rc X nd}{
1 add set}{1 add clr}{adv 2 chg}{adv 2 chg nd}{pop nd}]A{bind pop}
forall N/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/p{show}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0 N/Ry 0 N/V{}B/RV/v{
/Ry X/Rx X V}B statusdict begin/product where{pop false[(Display)(NeXT)
(LaserWriter 16/600)]{A length product length le{A length product exch 0
exch getinterval eq{pop true exit}if}{pop}ifelse}forall}{false}ifelse
end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{BDot}imagemask
grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat{BDot}
imagemask grestore}}ifelse B/QV{gsave newpath transform round exch round
exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0 rlineto
fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B/M{S p
delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}B/g{0 M}
B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p -3 w}B/n{
p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{0 S
rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: psfrag.pro
%%
%% This is file `psfrag.pro',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% psfrag.dtx  (with options: `filepro')
%% 
%% Copyright (c) 1996 Craig Barratt, Michael C. Grant, and David Carlisle.
%% All rights reserved.
%% 
%% This file is part of the PSfrag package.
%% 
userdict begin
/PSfragLib 90 dict def
/PSfragDict 6 dict def
/PSfrag { PSfragLib begin load exec end } bind def
end
PSfragLib begin
/RO /readonly      load def
/CP /currentpoint  load def
/CM /currentmatrix load def
/B { bind RO def } bind def
/X { exch def } B
/MD { { X } forall } B
/OE { end exec PSfragLib begin } B
/S false def
/tstr 8 string def
/islev2 { languagelevel } stopped { false } { 2 ge } ifelse def
[ /sM /tM /srcM /dstM /dM /idM /srcFM /dstFM ] { matrix def } forall
sM currentmatrix RO pop
dM defaultmatrix RO idM invertmatrix RO pop
srcFM identmatrix pop
/Hide { gsave { CP } stopped not newpath clip { moveto } if } B
/Unhide { { CP } stopped not grestore { moveto } if } B
/setrepl islev2 {{ /glob currentglobal def true setglobal array astore
                   globaldict exch /PSfrags exch put glob setglobal }}
                {{ array astore /PSfrags X }} ifelse B
/getrepl islev2 {{ globaldict /PSfrags get aload length }}
                {{ PSfrags aload length }} ifelse B
/convert {
   /src X src length string
   /c 0 def src length {
      dup c src c get dup 32 lt { pop 32 } if put /c c 1 add def
   } repeat
} B
/Begin {
    /saver save def
    srcFM exch 3 exch put
    0 ne /debugMode X 0 setrepl
    dup /S exch dict def { S 3 1 roll exch convert exch put } repeat
    srcM CM dup invertmatrix pop
    mark { currentdict { end } stopped { pop exit } if } loop
    PSfragDict counttomark { begin } repeat pop
} B
/End {
    mark { currentdict end dup PSfragDict eq { pop exit } if } loop
    counttomark { begin } repeat pop
    getrepl saver restore
    7 idiv dup /S exch dict def {
        6 array astore /mtrx X tstr cvs /K X
        S K [ S K known { S K get aload pop } if mtrx ] put
    } repeat
} B
/Place {
    tstr cvs /K X
    S K known {
        bind /proc X tM CM pop
        CP /cY X /cX X
        0 0 transform idtransform neg /aY X neg /aX X
        S K get dup length /maxiter X
        /iter 1 def {
            iter maxiter ne { /saver save def } if
            tM setmatrix aX aY translate
            [ exch aload pop idtransform ] concat
            cX neg cY neg translate cX cY moveto
            /proc load OE
            iter maxiter ne { saver restore /iter iter 1 add def } if
        } forall
        /noXY { CP /cY X /cX X } stopped def
        tM setmatrix noXY { newpath } { cX cY moveto } ifelse
    } {
        Hide OE Unhide
    } ifelse
} B
/normalize {
    2 index dup mul 2 index dup mul add sqrt div
    dup 4 -1 roll exch mul 3 1 roll mul
} B
/replace {
    aload pop MD
    CP /bY X /lX X gsave sM setmatrix
    str stringwidth abs exch abs add dup 0 eq
        { pop } { 360 exch div dup scale } ifelse
    lX neg bY neg translate newpath lX bY moveto
    str { /ch X ( ) dup 0 ch put false charpath ch Kproc } forall
    flattenpath pathbbox [ /uY /uX /lY /lX ] MD
    CP grestore moveto
    currentfont /FontMatrix get dstFM copy dup
    0 get 0 lt { uX lX /uX X /lX X } if
    3 get 0 lt { uY lY /uY X /lY X } if
    /cX uX lX add 0.5 mul def
    /cY uY lY add 0.5 mul def
    debugMode { gsave 0 setgray 1 setlinewidth
        lX lY moveto lX uY lineto uX uY lineto uX lY lineto closepath
        lX bY moveto uX bY lineto lX cY moveto uX cY lineto
        cX lY moveto cX uY lineto stroke
    grestore } if
    dstFM dup invertmatrix dstM CM srcM
    2 { dstM concatmatrix } repeat pop
    getrepl /temp X
        S str convert get {
            aload pop [ /rot /scl /loc /K ] MD
            /aX cX def /aY cY def
            loc {
                dup 66  eq { /aY bY def } { % B
                dup 98  eq { /aY lY def } { % b
                dup 108 eq { /aX lX def } { % l
                dup 114 eq { /aX uX def } { % r
                dup 116 eq { /aY uY def }   % t
                if } ifelse } ifelse } ifelse } ifelse pop
            } forall
            K srcFM rot tM rotate dstM
            2 { tM concatmatrix } repeat aload pop pop pop
            2 { scl normalize 4 2 roll } repeat
            aX aY transform
            /temp temp 7 add def
        } forall
    temp setrepl
} B
/Rif {
    S 3 index convert known { pop replace } { exch pop OE } ifelse
} B
/XA { bind [ /Kproc /str } B /XC { ] 2 array astore def } B
/xs   { pop } XA XC
/xks  { /kern load OE } XA /kern XC
/xas  { pop ax ay rmoveto } XA /ay /ax XC
/xws  { c eq { cx cy rmoveto } if } XA /c /cy /cx XC
/xaws { ax ay rmoveto c eq { cx cy rmoveto } if }
    XA /ay /ax /c /cy /cx XC
/raws { xaws { awidthshow } Rif } B
/rws  { xws { widthshow } Rif } B
/rks  { xks { kshow } Rif } B
/ras  { xas { ashow } Rif } B
/rs   { xs { show } Rif } B
/rrs { getrepl dup 2 add -1 roll //restore exec setrepl } B
PSfragDict begin
islev2 not { /restore { /rrs PSfrag } B } if
/show       { /rs   PSfrag } B
/kshow      { /rks  PSfrag } B
/ashow      { /ras  PSfrag } B
/widthshow  { /rws  PSfrag } B
/awidthshow { /raws PSfrag } B
end PSfragDict RO pop
end

%%EndProcSet
%%BeginProcSet: f7b6d320.enc
% Thomas Esser, Dec 2002. public domain
%
% Encoding for:
%     cmb10 cmbx10 cmbx12 cmbx5 cmbx6 cmbx7 cmbx8 cmbx9 cmbxsl10
%     cmdunh10 cmr10 cmr12 cmr17cmr6 cmr7 cmr8 cmr9 cmsl10 cmsl12 cmsl8
%     cmsl9 cmss10cmss12 cmss17 cmss8 cmss9 cmssbx10 cmssdc10 cmssi10
%     cmssi12 cmssi17 cmssi8cmssi9 cmssq8 cmssqi8 cmvtt10
%
/TeXf7b6d320Encoding [
/Gamma /Delta /Theta /Lambda /Xi /Pi /Sigma /Upsilon /Phi /Psi /Omega
/ff /fi /fl /ffi /ffl /dotlessi /dotlessj /grave /acute /caron /breve
/macron /ring /cedilla /germandbls /ae /oe /oslash /AE /OE /Oslash
/suppress /exclam /quotedblright /numbersign /dollar /percent /ampersand
/quoteright /parenleft /parenright /asterisk /plus /comma /hyphen
/period /slash /zero /one /two /three /four /five /six /seven /eight
/nine /colon /semicolon /exclamdown /equal /questiondown /question /at
/A /B /C /D /E /F /G /H /I /J /K /L /M /N /O /P /Q /R /S /T /U /V /W /X
/Y /Z /bracketleft /quotedblleft /bracketright /circumflex /dotaccent
/quoteleft /a /b /c /d /e /f /g /h /i /j /k /l /m /n /o /p /q /r /s /t /u
/v /w /x /y /z /endash /emdash /hungarumlaut /tilde /dieresis /suppress
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /space
/Gamma /Delta /Theta /Lambda /Xi /Pi /Sigma /Upsilon /Phi /Psi /.notdef
/.notdef /Omega /ff /fi /fl /ffi /ffl /dotlessi /dotlessj /grave /acute
/caron /breve /macron /ring /cedilla /germandbls /ae /oe /oslash /AE
/OE /Oslash /suppress /dieresis /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
] def

%%EndProcSet
%%BeginProcSet: texps.pro
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/psfts{S 65781.76 div N}N/startTexFig{/psf$SavedState
save N userdict maxlength dict begin/magscale true def normalscale
currentpoint TR/psf$ury psfts/psf$urx psfts/psf$lly psfts/psf$llx psfts
/psf$y psfts/psf$x psfts currentpoint/psf$cy X/psf$cx X/psf$sx psf$x
psf$urx psf$llx sub div N/psf$sy psf$y psf$ury psf$lly sub div N psf$sx
psf$sy scale psf$cx psf$sx div psf$llx sub psf$cy psf$sy div psf$ury sub
TR/showpage{}N/erasepage{}N/setpagedevice{pop}N/copypage{}N/p 3 def
@MacSetUp}N/doclip{psf$llx psf$lly psf$urx psf$ury currentpoint 6 2 roll
newpath 4 copy 4 2 roll moveto 6 -1 roll S lineto S lineto S lineto
closepath clip newpath moveto}N/endTexFig{end psf$SavedState restore}N
/@beginspecial{SDict begin/SpecialSave save N gsave normalscale
currentpoint TR @SpecialDefaults count/ocount X/dcount countdictstack N}
N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto 0 vs rlineto hs
neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale ang rotate
rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}ifelse
scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale llx neg
lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly lineto urx
ury lineto llx ury lineto closepath clip}if/showpage{}N/erasepage{}N
/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{count ocount sub{
pop}repeat countdictstack dcount sub{end}repeat grestore SpecialSave
restore end}N/@defspecial{SDict begin}N/@fedspecial{end}B/li{lineto}B
/rl{rlineto}B/rc{rcurveto}B/np{/SaveX currentpoint/SaveY X N 1
setlinecap newpath}N/st{stroke SaveX SaveY moveto}N/fil{fill SaveX SaveY
moveto}N/ellipse{/endangle X/startangle X/yrad X/xrad X/savematrix
matrix currentmatrix N TR xrad yrad scale 0 0 1 startangle endangle arc
savematrix setmatrix}N end

%%EndProcSet
TeXDict begin @defspecial

 /DvipsToPDF { 72.27 mul Resolution div } def /PDFToDvips { 72.27 div
Resolution mul } def /HyperBorder { 1 PDFToDvips } def /H.V {pdf@hoff
pdf@voff null} def /H.B {/Rect[pdf@llx pdf@lly pdf@urx pdf@ury]} def
/H.S { currentpoint HyperBorder add /pdf@lly exch def dup DvipsToPDF
/pdf@hoff exch def HyperBorder sub /pdf@llx exch def } def /H.L { 2
sub dup /HyperBasePt exch def PDFToDvips /HyperBaseDvips exch def currentpoint
HyperBaseDvips sub /pdf@ury exch def /pdf@urx exch def } def /H.A {
H.L currentpoint exch pop vsize 72 sub exch DvipsToPDF HyperBasePt
sub sub /pdf@voff exch def } def /H.R { currentpoint HyperBorder sub
/pdf@ury exch def HyperBorder add /pdf@urx exch def currentpoint exch
pop vsize 72 sub exch DvipsToPDF sub /pdf@voff exch def } def systemdict
/pdfmark known not {userdict /pdfmark systemdict /cleartomark get put}
if

 TeXDict begin /landplus90{true}store end
 
@fedspecial end
%%BeginFont: CMR12
%!PS-AdobeFont-1.1: CMR12 1.0
%%CreationDate: 1991 Aug 20 16:38:05
% Copyright (C) 1997 American Mathematical Society. All Rights Reserved.
11 dict begin
/FontInfo 7 dict dup begin
/version (1.0) readonly def
/Notice (Copyright (C) 1997 American Mathematical Society. All Rights Reserved) readonly def
/FullName (CMR12) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
end readonly def
/FontName /CMR12 def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /.notdef put
readonly def
/FontBBox{-34 -251 988 750}readonly def
/UniqueID 5000794 def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA052A014267B7904EB3C0D3BD0B83D891
016CA6CA4B712ADEB258FAAB9A130EE605E61F77FC1B738ABC7C51CD46EF8171
9098D5FEE67660E69A7AB91B58F29A4D79E57022F783EB0FBBB6D4F4EC35014F
D2DECBA99459A4C59DF0C6EBA150284454E707DC2100C15B76B4C19B84363758
469A6C558785B226332152109871A9883487DD7710949204DDCF837E6A8708B8
2BDBF16FBC7512FAA308A093FE5CF4E9D2405B169CD5365D6ECED5D768D66D6C
68618B8C482B341F8CA38E9BB9BAFCFAAD9C2F3FD033B62690986ED43D9C9361
3645B82392D5CAE11A7CB49D7E2E82DCD485CBA04C77322EB2E6A79D73DC194E
59C120A2DABB9BF72E2CF256DD6EB54EECBA588101ABD933B57CE8A3A0D16B28
51D7494F73096DF53BDC66BBF896B587DF9643317D5F610CD9088F9849126F23
DDE030F7B277DD99055C8B119CAE9C99158AC4E150CDFC2C66ED92EBB4CC092A
AA078CE16247A1335AD332DAA950D20395A7384C33FF72EAA31A5B89766E635F
45C4C068AD7EE867398F0381B07CB94D29FF097D59FF9961D195A948E3D87C31
821E9295A56D21875B41988F7A16A1587050C3C71B4E4355BB37F255D6B237CE
96F25467F70FA19E0F85785FF49068949CCC79F2F8AE57D5F79BB9C5CF5EED5D
9857B9967D9B96CDCF73D5D65FF75AFABB66734018BAE264597220C89FD17379
26764A9302D078B4EB0E29178C878FD61007EEA2DDB119AE88C57ECFEF4B71E4
140A34951DDC3568A84CC92371A789021A103A1A347050FDA6ECF7903F67D213
1D0C7C474A9053866E9C88E65E6932BA87A73686EAB0019389F84D159809C498
1E7A30ED942EB211B00DBFF5BCC720F4E276C3339B31B6EABBB078430E6A09BB
377D3061A20B1EB98796B8607EECBC699445EAA866C38E02DF59F5EDD378303A
0733B90E7835C0AAF32BA04F1566D8161EA89CD4D14DDB953F8B910BFC8A7F03
5020F55EF8FC2640ADADA156F6CF8F2EB6610F7EE8874A26CBE7CD154469B9F4
ED76886B3FB679FFDEB59BB6C55AF7087BA48B75EE2FB374B19BCC421A963E15
FE05ECAAF9EECDF4B2715010A320102E6F8CCAA342FA11532671CD8AB8FF325A
62FC5DD3D91489C6571ABED041EEA1C303DB075A7895655913BE64EB4844C354
ADE2CE9E8E7DC0A1AC3338FD8183D17F0009F554588EA96FF6AE1CFFA363F96C
A31180159710FD95A07CABA7CCE0573D0114271BD3A048D2542CE832C33A799D
CCD6E0B9FBB6D65574C20B23A840C8779F76B852AB7E1AC17284B220DF2F6C88
BA48578BF082376203BDDADA15CA597CB1A4266AE02A98715D2F2C7E6A92F281
23F800FE0D805C245F8EE16A90BB5609A96FE1576B38B8657F1F3BBC6BBA09D9
480D71F2AD8F3910C47EFE44C931964986786701E0889591DBB2394387E0FD42
661BD377234149F350A6B03B991CB54F0C52DD06C24FA7B7A91ED4C966461CD5
61C58A00D3EC36D02D0D1740F2C9CCFFFDC4F65F307013583A3AFE7DA47E4D07
CF80DB880B5B0ADF5B83052A1F3BC7D80F154F159D4B46C8C68B7F1351429002
6BEA78AD8086CF36EB31530E2B931987410D9629412BB8F5B8F134AE6A3EF762
F54AED671EC454FB8FD497B4E6767D178667B7F7B0DEA361FF9C184FA430659D
58043E465C752DC90A4B2224A9E2F3056095B083E5A9B188C1FEBF121285ABB8
F8CABA3CDA1742EB592A8E9A889A77F7E175CB6EAC72089B6E7A7535F88F910E
4A0BC1FE1B73E58985EB667FBA035A70DE5D8A2FCB1D5323143B8ED75FC77407
EB9232585813471DE4A6B40646B6816E4FA420783D069CFF37931C0E42C3FE50
B2C2EFD74B639F896597B9737892106C318FD1C00BE430990DD2C160541E4637
C0BC9793ACCDD8615A648EE14D46DD9530EF0D5C4539A5221679EF31CC15C3BD
D542FC5ACE7D0AD08CC8AFB966793BE26F02847C673739327C96E56C0C6F4740
48E16EBF386565F866C3B2E0ABEDB251B7FE666478BBEC8AC3F31AAE586F5F18
2AB07349A8838D4928446CEA26E7E6FD50403337F5A5FA8FA13E76FBA8BE672C
6B2150FC7995343A2DFF1DD542A45C08B5C66F9A8B3A5A5E136FE0457D2BE0E1
3D190823A3F177EC8880E95F3F19441A06576FF75989B819F0136C5DA2A7F7BC
79C9BE9047EAEF63AF3FC2F9B9C36C7FBF9B23C0F5E0D75E7EE6E5DAC14D547E
C7E0CB6669DF4709E0F6E9422B1ACEA25BE76E2F2D88081E1E4EE60BB3C18F0D
2FBAC9FB964233EAC6747C235B17DDD266C89E2A5CAB19A62376D275C86CF4B7
A8D79CD2315953407024AA0550561DAD5F44B7B26ABE5E5C693BF9965E648E5E
0EB2F6279150C5341C8CA1006B62FB15E1F356900EFBD5E80590165D93562790
7284DCF7B4F7B518224B01B91AB7BF2CF21201A8E25C4CBBD423A4A856EA8F1E
0558682EF56A0EB6CBCF10C87DCE42381A68C163830753096B3526E380B5A28D
3CD1406D5B5AAB853191DA7EC93F2BB90D6E1DD3C53339D37E9F274E0AA392F9
AA43C0891AF4E827505B07A6D1063A7A5BFBCBD8A7A19DB809530BD65F29B68A
4D7CB550BF5CC52915A314FA28B19DA6D9D4837A89E5919D1F6CCF45A7ED70F4
76E7B2AD7083781D5465D3D141B6E2AE9B09EA2C52A720F2A27140DDBC97F279
600D9C5F8B012E11C4AB25990426F115E05EAFB07C3060ED9EBFDB6D0EA011D9
AD34E6EFBC7FA2EC113D8976ACBAD5306C86B28A840EF6DE8EB47AF56491ACE7
C71D420A3FE626C5B085F297FCBA78F5BF120F677E9314D1BFCDC6ED802940CD
CB7D96B13A1515E6BC841724DE526723491E2A0BED70B2161E20A0B1AFFDCEBD
3D5F85756FDAFC97293C6E290F6DD7733E4DEA480D33290E4096375C7A85F1AE
3C6497544D487DDDFD07491933F55E932F1BBCF6F2878AC70242D741C4643810
1C4612F2059FE09792C1C1F346BAA230E4793B2359831896A8EC2C75838138D8
A658F2226F299600BA7875D72131FA4B34BB4907217EF798A61515C8769F896D
F640B750E8C3F52DAFB871EDF941681E18B3400220020B68CAA8FAA8FCBC7092
5A95C0754B175D45DB3A62B389EBC9A0055AB29A13FB9E6D22A7CB3AD555C10F
7E72092205D77F896FB2826078D0406B103F94F0EAF83C3B61D330D6D243F51B
73746FE92AFCD6D951B651C492DA4016DCFF4A91871231FA00D799B189664C72
2551030066BF5E902AE5DC51F395D5AF3C438283DC6A59685C9BFFE5E5CC9154
A0D0216C15589AD8B7AEDA47B981824B047F5878DF25373D0795CCDA09FDF9C5
EC5C243FF89DDA4378BC0AA296C66B1C6D7CD27389149D930B2275E8D7FACCDA
9BFC0EA0979B26D5ECF706C017190B4F515E56D1F44A1847F03F136A55D85A95
AB83635C048DE9148CAE263A0014F0A09FE4F178E2BAAA9E3095E7FA33D31C7E
0AABFD0C2133451371D22B94D2EF851F19B3DB379AAE21EE01EC1B8BDB2FAF77
9599E1B5EF89382773CF9E992745D18C5FFBA3EAB8E1312942A9A582E7F52347
C68BC023ED5989250E53BE697244785CDE165459BA844605024B6860AD8C5569
31842F3FDFF080545E5C95D75FF9AAA4F6DECBB578B607AD111F352D023A34B8
03879B9A4C32675153F1978170B50A764DAA058955721B7052C7653FE09FB575
242881BD1CB57682735A31A8F62266DCF20FE3E96E82A7BD95E8F0DA73156DFA
8A70417BC33E0E4E63E1BE1526814489D209A8CCD3A52698F20AE88EA5178BC4
E9EBB5984353D90265F28FED75376E42E7D08C4574868CDBEDCA1F45235EFED7
E8F8A8C081EC25B7B274224F76BEC9C933FBE7D106E88117CF9027F4D5EA8B9B
38AFD2734D05AE550D9E2D1D732FB2ABFCA208B4A928E3E4770C639D2FA4D200
7D23258457EB79D809F75993A4BF871DE04FF89924E6DA18411DFC23AD19778C
487720BB182C34A1934DF9ED0A644B2CB04FEA59C3C971BE6E5F6C9B36A33F93
AF3DD8CF3796E5093086B729E2BD9DC0895D6C4440931D21EC5BAD14CDBCB981
ACB2FEA670B16385D7A2EE54AFC78EAD24B29E5E4C3A98D0DC04D0E082F12D3D
230934C5A8B444D76D1FB361C1700C039078FA0AF0B4FC1438321346603490D4
CBD49139AEC4DFB4D9AA812EC0BB04574295C4D89F5D2AAF1E93BD8B06E07A9E
A1E43A5F8AD5648706DA31A4476591449FBA8368A19B9289F0C8863F6C3DCC78
E3CF06F05D1A3282CB606CBF7BB35E90A8CFD9B70253DD714F283A9BDCEAF41B
9FAE4F986EBD3E613D5597BD468F4A7E662A75F8D18B9A6F85342D1A12E9E66C
FB27A0156EDDFB145FE0910EF1728C5ADA3F75E63621574AC707921BEF7BC364
E54E1036011EBEBFE0AEBD8822BA16A354F6218472C11A571DF4DAC94E5FCB3F
9E1C53375B09F98312BE4041460D5A1E36F6039851BD4EFBEEFED01B5AA2B00B
7903E99BF2A06ED8EBD75A6C87D08B88BB8666C05326395BE8BEF7C58E1404A7
46F9C3F4DE691C9B766E9C10CE9F1B560C23BE5FE56FFCBC7FB7456210D46C1D
5C261640A06BAEA43053FBC5BBA047FA517FC45917E25EB8659F06761602FEA1
E965095929BE3E2B65ADF0D8735BF340E43A7EC876DF07E99B7782A67B29C32A
9428B18723AA556FFBFFC6496EB185975D3F8087C42DE59E6CE7208BCB4100B5
3F6FA6350B1C82F9469D9D6B219D1D2AEC5A4AEA7EF317A2170BC820EB3E20BD
60A374AA5BC276EBD3A5B5060F8E4FD505996227B4D1AE1FF9EA9D753E711D28
06B134C69F8B42B5E449246FA0E6C7A868D9E320E3F1AF38517F385FA8294268
D4AEBAC48C0C8D746FDC9682A1F19D1903FCACC58306056619EE8D7D335B42F0
859C7F12431CF0C63D914A70476A1F00D00DC64EF37195B27DCD4C59E12B1EF7
030E6AA2572E077A5EB49F262F0CEEA5B26D7F7CCE853EE289D5DE95D067F521
6AD1E148CCDB7EE008E97B414799CF8873D5C8E894A9589FE9B9A0C09DEF472D
F5F706799EA627F6B8D45421ED407E6F4CC881D2E9DADBA7C1AD1E455A74ABB0
F9FEDA44DBABE3064F24E448D6CD15502679A59BF1D6980656DB9B558292DAD4
EE81C90C7E93118D7BD3D8593370827C905AB9EA25FC01ED3082D47BB90B30A9
F201D03222EB5CFC0FA51B98537277A2FE87F5AB309A3824EE37ABADEBE61A45
A0A65D09740A04E085A20A82D7D9A5B316AC24D8BFA243D31226CD644A050EBB
7B0BA8E49483EC8A75457E36E6640D4E41C84685BD3E5B5E9ADA582E3819E968
75C072040F78042E6CAC7E7D2034759D92AF3AF020A69C098EB3C401EA6AE75E
3AFC8D902BCB562322E92B67B7BA8F5CEF2FBD19729C511FD95CBD3F1D6B481C
E337FA1DED05126617FF7643B6A7CF7B0D650A82055F2F49A695A0EADDD6C5F9
D9FE4142064E563295A6D917550B59454796FF1010442110F60D0295BAD1EF38
5ED33E5EFD5EF3CBE2324EE5DB1C0D255AD63BDD12629D056B47B584E95B9980
051E673D012CA717A6D3AEDD28958389C06BCA8B423CB0FDBAFAF46D4B23F4C8
EC4D9DFF5D88B19DCF74FD70DE05CDC6921B782CF6D46A1E2F57E0D7FB7A5628
280CA54DCD02FB350A9ACE88DF06C617BB95D81872C588E26A3A028EC60D1079
D58D8D8433D3944D8ED61431BE734370C60A8BF2D913ECC81883E2E52CE6C66D
D21D364ED8A12FE8C7A5EE5DFD07AC90A3CF30AC9450861EC2D6BCE3B68DDEF8
382D85BA8B95BE48ADA96A635BDEAB077D9D86BD462140AB56CA540F50588099
1B18A7DE2858E79E0F0723D0E17265A77E7C302D0E86FDD0B3804A3A04A6B6B8
90D10EC2334760A7EE55F5567BFE179E8D3C2CC7F8304D78C2FB32D6357DC586
73F28881
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
TeXDict begin 40258437 52099154 1000 8000 8000 (img.dvi)
@start /Fa 138[723 506 513 506 1[723 1[723 1084 361 2[361
723 650 397 578 1[578 723 650 13[723 2[885 3[813 10[975
65[{ TeXf7b6d320Encoding ReEncodeFont }20 1328.35 /CMR12
rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 8000dpi
TeXDict begin
 end
%%EndSetup
TeXDict begin 1 0 bop 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a 0 0 a
SDict begin [ /Title (Untersuchung einer Antriebswelle) /Subject (Projektstudie LaTeX@TUG)
/Creator (Accomplished with LaTeX2e and pdfLaTeX with hyperref-package.)
/Author (Prokop, Sollerer, Voit) /Producer () /Keywords () /DOCINFO
pdfmark end
 0 0 a 268 1802
a
SDict begin H.S end
 268 1802 a 268 1802 a
SDict begin H.R end
 268 1802 a 268 1802 a
SDict begin [ /View [/XYZ H.V] /Dest (page.1) cvn H.B /DEST pdfmark
end
 268 1802
a 268 4209 a
SDict begin [ /Page 1 /View [ /Fit ] /PageMode /UseOutlines  /DOCVIEW
pdfmark end
 268 4209 a 268 4209 a
SDict begin [ {Catalog} << /ViewerPreferences << >> >> /PUT pdfmark
end
 268 4209 a 268 4209
a
SDict begin H.S end
 268 4209 a 268 4209 a
SDict begin 14.5 H.A end
 268 4209 a 268 4209 a
SDict begin [ /View [/XYZ H.V] /Dest (Doc-Start) cvn H.B /DEST pdfmark
end
 268 4209
a 268 17739 a
 /PSfrag where{pop(Lager)[[0(c)1 0]](Antrieb)[[1(c)1 0]](Schleifscheibe)[[2(r)1
0]]3 0 -1/Begin PSfrag}{userdict /PSfrag{pop}put}ifelse
 268 17739 a @beginspecial 0 @llx 0 @lly
616 @urx 240 @ury 3125 @rwi @setspecial
%%BeginDocument: /home/solli/latex/temp/tug/images/schema_img.eps
%!PS-Adobe-2.0 EPSF-2.0
%%Title: schema_img.fig
%%Creator: fig2dev Version 3.2 Patchlevel 4
%%CreationDate: Wed Jun 30 13:24:29 2004
%%For: solli@ffestpc01.tu-graz.ac.at ()
%%BoundingBox: 0 0 616 240
%%Magnification: 1.0000
%%EndComments
/MyAppDict 100 dict dup begin def
/$F2psDict 200 dict def
$F2psDict begin
$F2psDict /mtrx matrix put
/col-1 {0 setgray} bind def
/col0 {0.000 0.000 0.000 srgb} bind def
/col1 {0.000 0.000 1.000 srgb} bind def
/col2 {0.000 1.000 0.000 srgb} bind def
/col3 {0.000 1.000 1.000 srgb} bind def
/col4 {1.000 0.000 0.000 srgb} bind def
/col5 {1.000 0.000 1.000 srgb} bind def
/col6 {1.000 1.000 0.000 srgb} bind def
/col7 {1.000 1.000 1.000 srgb} bind def
/col8 {0.000 0.000 0.560 srgb} bind def
/col9 {0.000 0.000 0.690 srgb} bind def
/col10 {0.000 0.000 0.820 srgb} bind def
/col11 {0.530 0.810 1.000 srgb} bind def
/col12 {0.000 0.560 0.000 srgb} bind def
/col13 {0.000 0.690 0.000 srgb} bind def
/col14 {0.000 0.820 0.000 srgb} bind def
/col15 {0.000 0.560 0.560 srgb} bind def
/col16 {0.000 0.690 0.690 srgb} bind def
/col17 {0.000 0.820 0.820 srgb} bind def
/col18 {0.560 0.000 0.000 srgb} bind def
/col19 {0.690 0.000 0.000 srgb} bind def
/col20 {0.820 0.000 0.000 srgb} bind def
/col21 {0.560 0.000 0.560 srgb} bind def
/col22 {0.690 0.000 0.690 srgb} bind def
/col23 {0.820 0.000 0.820 srgb} bind def
/col24 {0.500 0.190 0.000 srgb} bind def
/col25 {0.630 0.250 0.000 srgb} bind def
/col26 {0.750 0.380 0.000 srgb} bind def
/col27 {1.000 0.500 0.500 srgb} bind def
/col28 {1.000 0.630 0.630 srgb} bind def
/col29 {1.000 0.750 0.750 srgb} bind def
/col30 {1.000 0.880 0.880 srgb} bind def
/col31 {1.000 0.840 0.000 srgb} bind def

end
save
newpath 0 240 moveto 0 0 lineto 616 0 lineto 616 240 lineto closepath clip newpath
-34.0 353.0 translate
1 -1 scale

% This junk string is used by the show operators
/PATsstr 1 string def
/PATawidthshow { 	% cx cy cchar rx ry string
  % Loop over each character in the string
  {  % cx cy cchar rx ry char
    % Show the character
    dup				% cx cy cchar rx ry char char
    PATsstr dup 0 4 -1 roll put	% cx cy cchar rx ry char (char)
    false charpath		% cx cy cchar rx ry char
    /clip load PATdraw
    % Move past the character (charpath modified the
    % current point)
    currentpoint			% cx cy cchar rx ry char x y
    newpath
    moveto			% cx cy cchar rx ry char
    % Reposition by cx,cy if the character in the string is cchar
    3 index eq {			% cx cy cchar rx ry
      4 index 4 index rmoveto
    } if
    % Reposition all characters by rx ry
    2 copy rmoveto		% cx cy cchar rx ry
  } forall
  pop pop pop pop pop		% -
  currentpoint
  newpath
  moveto
} bind def
/PATcg {
  7 dict dup begin
    /lw currentlinewidth def
    /lc currentlinecap def
    /lj currentlinejoin def
    /ml currentmiterlimit def
    /ds [ currentdash ] def
    /cc [ currentrgbcolor ] def
    /cm matrix currentmatrix def
  end
} bind def
% PATdraw - calculates the boundaries of the object and
% fills it with the current pattern
/PATdraw {			% proc
  save exch
    PATpcalc			% proc nw nh px py
    5 -1 roll exec		% nw nh px py
    newpath
    PATfill			% -
  restore
} bind def
% PATfill - performs the tiling for the shape
/PATfill { % nw nh px py PATfill -
  PATDict /CurrentPattern get dup begin
    setfont
    % Set the coordinate system to Pattern Space
    PatternGState PATsg
    % Set the color for uncolored pattezns
    PaintType 2 eq { PATDict /PColor get PATsc } if
    % Create the string for showing
    3 index string		% nw nh px py str
    % Loop for each of the pattern sources
    0 1 Multi 1 sub {		% nw nh px py str source
	% Move to the starting location
	3 index 3 index		% nw nh px py str source px py
	moveto			% nw nh px py str source
	% For multiple sources, set the appropriate color
	Multi 1 ne { dup PC exch get PATsc } if
	% Set the appropriate string for the source
	0 1 7 index 1 sub { 2 index exch 2 index put } for pop
	% Loop over the number of vertical cells
	3 index 		% nw nh px py str nh
	{			% nw nh px py str
	  currentpoint		% nw nh px py str cx cy
	  2 index oldshow	% nw nh px py str cx cy
	  YStep add moveto	% nw nh px py str
	} repeat		% nw nh px py str
    } for
    5 { pop } repeat
  end
} bind def

% PATkshow - kshow with the current pattezn
/PATkshow {			% proc string
  exch bind			% string proc
  1 index 0 get			% string proc char
  % Loop over all but the last character in the string
  0 1 4 index length 2 sub {
				% string proc char idx
    % Find the n+1th character in the string
    3 index exch 1 add get	% string proc char char+1
    exch 2 copy			% strinq proc char+1 char char+1 char
    % Now show the nth character
    PATsstr dup 0 4 -1 roll put	% string proc chr+1 chr chr+1 (chr)
    false charpath		% string proc char+1 char char+1
    /clip load PATdraw
    % Move past the character (charpath modified the current point)
    currentpoint newpath moveto
    % Execute the user proc (should consume char and char+1)
    mark 3 1 roll		% string proc char+1 mark char char+1
    4 index exec		% string proc char+1 mark...
    cleartomark			% string proc char+1
  } for
  % Now display the last character
  PATsstr dup 0 4 -1 roll put	% string proc (char+1)
  false charpath		% string proc
  /clip load PATdraw
  neewath
  pop pop			% -
} bind def
% PATmp - the makepattern equivalent
/PATmp {			% patdict patmtx PATmp patinstance
  exch dup length 7 add		% We will add 6 new entries plus 1 FID
  dict copy			% Create a new dictionary
  begin
    % Matrix to install when painting the pattern
    TilingType PATtcalc
    /PatternGState PATcg def
    PatternGState /cm 3 -1 roll put
    % Check for multi pattern sources (Level 1 fast color patterns)
    currentdict /Multi known not { /Multi 1 def } if
    % Font dictionary definitions
    /FontType 3 def
    % Create a dummy encoding vector
    /Encoding 256 array def
    3 string 0 1 255 {
      Encoding exch dup 3 index cvs cvn put } for pop
    /FontMatrix matrix def
    /FontBBox BBox def
    /BuildChar {
	mark 3 1 roll		% mark dict char
	exch begin
	Multi 1 ne {PaintData exch get}{pop} ifelse  % mark [paintdata]
	  PaintType 2 eq Multi 1 ne or
	  { XStep 0 FontBBox aload pop setcachedevice }
	  { XStep 0 setcharwidth } ifelse
	  currentdict		% mark [paintdata] dict
	  /PaintProc load	% mark [paintdata] dict paintproc
	end
	gsave
	  false PATredef exec true PATredef
	grestore
	cleartomark		% -
    } bind def
    currentdict
  end				% newdict
  /foo exch			% /foo newlict
  definefont			% newfont
} bind def
% PATpcalc - calculates the starting point and width/height
% of the tile fill for the shape
/PATpcalc {	% - PATpcalc nw nh px py
  PATDict /CurrentPattern get begin
    gsave
	% Set up the coordinate system to Pattern Space
	% and lock down pattern
	PatternGState /cm get setmatrix
	BBox aload pop pop pop translate
	% Determine the bounding box of the shape
	pathbbox			% llx lly urx ury
    grestore
    % Determine (nw, nh) the # of cells to paint width and height
    PatHeight div ceiling		% llx lly urx qh
    4 1 roll				% qh llx lly urx
    PatWidth div ceiling		% qh llx lly qw
    4 1 roll				% qw qh llx lly
    PatHeight div floor			% qw qh llx ph
    4 1 roll				% ph qw qh llx
    PatWidth div floor			% ph qw qh pw
    4 1 roll				% pw ph qw qh
    2 index sub cvi abs			% pw ph qs qh-ph
    exch 3 index sub cvi abs exch	% pw ph nw=qw-pw nh=qh-ph
    % Determine the starting point of the pattern fill
    %(px, py)
    4 2 roll				% nw nh pw ph
    PatHeight mul			% nw nh pw py
    exch				% nw nh py pw
    PatWidth mul exch			% nw nh px py
  end
} bind def

% Save the original routines so that we can use them later on
/oldfill	/fill load def
/oldeofill	/eofill load def
/oldstroke	/stroke load def
/oldshow	/show load def
/oldashow	/ashow load def
/oldwidthshow	/widthshow load def
/oldawidthshow	/awidthshow load def
/oldkshow	/kshow load def

% These defs are necessary so that subsequent procs don't bind in
% the originals
/fill	   { oldfill } bind def
/eofill	   { oldeofill } bind def
/stroke	   { oldstroke } bind def
/show	   { oldshow } bind def
/ashow	   { oldashow } bind def
/widthshow { oldwidthshow } bind def
/awidthshow { oldawidthshow } bind def
/kshow 	   { oldkshow } bind def
/PATredef {
  MyAppDict begin
    {
    /fill { /clip load PATdraw newpath } bind def
    /eofill { /eoclip load PATdraw newpath } bind def
    /stroke { PATstroke } bind def
    /show { 0 0 null 0 0 6 -1 roll PATawidthshow } bind def
    /ashow { 0 0 null 6 3 roll PATawidthshow }
    bind def
    /widthshow { 0 0 3 -1 roll PATawidthshow }
    bind def
    /awidthshow { PATawidthshow } bind def
    /kshow { PATkshow } bind def
  } {
    /fill   { oldfill } bind def
    /eofill { oldeofill } bind def
    /stroke { oldstroke } bind def
    /show   { oldshow } bind def
    /ashow  { oldashow } bind def
    /widthshow { oldwidthshow } bind def
    /awidthshow { oldawidthshow } bind def
    /kshow  { oldkshow } bind def
    } ifelse
  end
} bind def
false PATredef
% Conditionally define setcmykcolor if not available
/setcmykcolor where { pop } {
  /setcmykcolor {
    1 sub 4 1 roll
    3 {
	3 index add neg dup 0 lt { pop 0 } if 3 1 roll
    } repeat
    setrgbcolor - pop
  } bind def
} ifelse
/PATsc {		% colorarray
  aload length		% c1 ... cn length
    dup 1 eq { pop setgray } { 3 eq { setrgbcolor } { setcmykcolor
  } ifelse } ifelse
} bind def
/PATsg {		% dict
  begin
    lw setlinewidth
    lc setlinecap
    lj setlinejoin
    ml setmiterlimit
    ds aload pop setdash
    cc aload pop setrgbcolor
    cm setmatrix
  end
} bind def

/PATDict 3 dict def
/PATsp {
  true PATredef
  PATDict begin
    /CurrentPattern exch def
    % If it's an uncolored pattern, save the color
    CurrentPattern /PaintType get 2 eq {
      /PColor exch def
    } if
    /CColor [ currentrgbcolor ] def
  end
} bind def
% PATstroke - stroke with the current pattern
/PATstroke {
  countdictstack
  save
  mark
  {
    currentpoint strokepath moveto
    PATpcalc				% proc nw nh px py
    clip newpath PATfill
    } stopped {
	(*** PATstroke Warning: Path is too complex, stroking
	  with gray) =
    cleartomark
    restore
    countdictstack exch sub dup 0 gt
	{ { end } repeat } { pop } ifelse
    gsave 0.5 setgray oldstroke grestore
  } { pop restore pop } ifelse
  newpath
} bind def
/PATtcalc {		% modmtx tilingtype PATtcalc tilematrix
  % Note: tiling types 2 and 3 are not supported
  gsave
    exch concat					% tilingtype
    matrix currentmatrix exch			% cmtx tilingtype
    % Tiling type 1 and 3: constant spacing
    2 ne {
	% Distort the pattern so that it occupies
	% an integral number of device pixels
	dup 4 get exch dup 5 get exch		% tx ty cmtx
	XStep 0 dtransform
	round exch round exch			% tx ty cmtx dx.x dx.y
	XStep div exch XStep div exch		% tx ty cmtx a b
	0 YStep dtransform
	round exch round exch			% tx ty cmtx a b dy.x dy.y
	YStep div exch YStep div exch		% tx ty cmtx a b c d
	7 -3 roll astore			% { a b c d tx ty }
    } if
  grestore
} bind def
/PATusp {
  false PATredef
  PATDict begin
    CColor PATsc
  end
} bind def

% crosshatch45
11 dict begin
/PaintType 1 def
/PatternType 1 def
/TilingType 1 def
/BBox [0 0 1 1] def
/XStep 1 def
/YStep 1 def
/PatWidth 1 def
/PatHeight 1 def
/Multi 2 def
/PaintData [
  { clippath } bind
  { 20 20 true [ 20 0 0 -20 0 20 ]
	{<8020004050102088201104400a02800401000a02
	8011044020882040501080200040501020882011
	04400a02800401000a0280110440208820405010>}
     imagemask } bind
] def
/PaintProc {
	pop
	exec fill
} def
currentdict
end
/P6 exch def

/cp {closepath} bind def
/ef {eofill} bind def
/gr {grestore} bind def
/gs {gsave} bind def
/sa {save} bind def
/rs {restore} bind def
/l {lineto} bind def
/m {moveto} bind def
/rm {rmoveto} bind def
/n {newpath} bind def
/s {stroke} bind def
/sh {show} bind def
/slc {setlinecap} bind def
/slj {setlinejoin} bind def
/slw {setlinewidth} bind def
/srgb {setrgbcolor} bind def
/rot {rotate} bind def
/sc {scale} bind def
/sd {setdash} bind def
/ff {findfont} bind def
/sf {setfont} bind def
/scf {scalefont} bind def
/sw {stringwidth} bind def
/tr {translate} bind def
/tnt {dup dup currentrgbcolor
  4 -2 roll dup 1 exch sub 3 -1 roll mul add
  4 -2 roll dup 1 exch sub 3 -1 roll mul add
  4 -2 roll dup 1 exch sub 3 -1 roll mul add srgb}
  bind def
/shd {dup dup currentrgbcolor 4 -2 roll mul 4 -2 roll mul
  4 -2 roll mul srgb} bind def
/$F2psBegin {$F2psDict begin /$F2psEnteredState save def} def
/$F2psEnd {$F2psEnteredState restore end} def

$F2psBegin
10 setmiterlimit
0 slj 0 slc
 0.06000 0.06000 sc
%
% Fig objects follow
%
% 
% here starts figure with depth 200
% Polyline
7.500 slw
n 8712 5372 m
 8098 5372 l gs col0 s gr 
% Polyline
n 8712 5372 m
 8558 5526 l gs col0 s gr 
% Polyline
n 8558 5372 m
 8405 5526 l gs col0 s gr 
% Polyline
n 8405 5372 m
 8251 5526 l gs col0 s gr 
% Polyline
n 8251 5372 m
 8098 5526 l gs col0 s gr 
% Polyline
n 4213 5397 m
 3599 5397 l gs col0 s gr 
% Polyline
n 4213 5397 m
 4059 5551 l gs col0 s gr 
% Polyline
n 4059 5397 m
 3906 5551 l gs col0 s gr 
% Polyline
n 3906 5397 m
 3752 5551 l gs col0 s gr 
% Polyline
n 3752 5397 m
 3599 5551 l gs col0 s gr 
% Polyline
n 2853 5100 m
 2475 5100 l gs col0 s gr 
% Polyline
n 2853 5100 m
 2758 5195 l gs col0 s gr 
% Polyline
n 2758 5100 m
 2664 5195 l gs col0 s gr 
% Polyline
n 2664 5100 m
 2569 5195 l gs col0 s gr 
% Polyline
n 2569 5100 m
 2475 5195 l gs col0 s gr 
% Polyline
n 2478 5100 m
 2100 5100 l gs col0 s gr 
% Polyline
n 2478 5100 m
 2383 5195 l gs col0 s gr 
% Polyline
n 2383 5100 m
 2289 5195 l gs col0 s gr 
% Polyline
n 2289 5100 m
 2194 5195 l gs col0 s gr 
% Polyline
n 2194 5100 m
 2100 5195 l gs col0 s gr 
% Polyline
n 2103 5100 m
 1725 5100 l gs col0 s gr 
% Polyline
n 2103 5100 m
 2008 5195 l gs col0 s gr 
% Polyline
n 2008 5100 m
 1914 5195 l gs col0 s gr 
% Polyline
n 1914 5100 m
 1819 5195 l gs col0 s gr 
% Polyline
n 1819 5100 m
 1725 5195 l gs col0 s gr 
% Polyline
n 1728 5100 m
 1350 5100 l gs col0 s gr 
% Polyline
n 1728 5100 m
 1633 5195 l gs col0 s gr 
% Polyline
n 1633 5100 m
 1539 5195 l gs col0 s gr 
% Polyline
n 1539 5100 m
 1444 5195 l gs col0 s gr 
% Polyline
n 1444 5100 m
 1350 5195 l gs col0 s gr 
% Polyline
n 1353 5100 m
 975 5100 l gs col0 s gr 
% Polyline
n 1353 5100 m
 1258 5195 l gs col0 s gr 
% Polyline
n 1258 5100 m
 1164 5195 l gs col0 s gr 
% Polyline
n 1164 5100 m
 1069 5195 l gs col0 s gr 
% Polyline
n 1069 5100 m
 975 5195 l gs col0 s gr 
% Polyline
n 978 5100 m
 600 5100 l gs col0 s gr 
% Polyline
n 978 5100 m
 883 5195 l gs col0 s gr 
% Polyline
n 883 5100 m
 789 5195 l gs col0 s gr 
% Polyline
n 789 5100 m
 694 5195 l gs col0 s gr 
% Polyline
n 694 5100 m
 600 5195 l gs col0 s gr 
% here ends figure;
% 
% here starts figure with depth 50
% Polyline
30.000 slw
n 3000 3900 m 9900 3900 l 9900 4500 l 3000 4500 l
 cp gs col0 s gr 
% Polyline
n 3000 3600 m 2850 3600 l 2850 4800 l 3000 4800 l
 cp gs col0 s gr 
% Polyline
n 2850 3300 m 600 3300 l 600 5100 l 2850 5100 l
 cp gs col0 s gr 
% Polyline
n 3600 3000 m 4200 3000 l 4200 5400 l 3600 5400 l
 cp gs col7 1.00 shd ef gr gs col0 s gr 
% Polyline
n 8100 3000 m 8700 3000 l 8700 5400 l 8100 5400 l
 cp gs col7 1.00 shd ef gr gs col0 s gr 
% Polyline
7.500 slw
n 4365 3270 m 6103 2759 l
 7965 3255 l gs col0 s gr 
% Polyline
n 9750 2175 m
 10170 2460 l gs col0 s gr 
% Polyline
30.000 slw
n 10005 2550 m 9900 2550 9900 5745 105 arcto 4 {pop} repeat
  9900 5850 10695 5850 105 arcto 4 {pop} repeat
  10800 5850 10800 2655 105 arcto 4 {pop} repeat
  10800 2550 10005 2550 105 arcto 4 {pop} repeat
 cp gs /PC [[1.00 1.00 1.00] [0.00 0.00 0.00]] def
15.00 15.00 sc P6 [16 0 0 -16 660.00 170.00] PATmp PATsp ef gr PATusp gs col0 s gr 
/Times-Roman ff 180.00 scf sf
1664 4283 m
gs 1 -1 sc (Antrieb) dup sw pop 2 div neg 0 rm  col0 sh gr
/Times-Roman ff 180.00 scf sf
9900 2025 m
gs 1 -1 sc (Schleifscheibe) dup sw pop neg 0 rm  col0 sh gr
/Times-Roman ff 180.00 scf sf
6120 2550 m
gs 1 -1 sc (Lager) dup sw pop 2 div neg 0 rm  col0 sh gr
% here ends figure;
$F2psEnd
rs
end
showpage

%%EndDocument
 @endspecial 268 17739 a
 /End PSfrag
 268 17739 a 268 11486 a
 /Hide PSfrag
 268
11486 a -11305 12400 a Fa(PS)n(frag)431 b(rep)n(lacemen)-38
b(ts)p -11305 12870 11573 54 v 268 12923 a
 /Unhide PSfrag
 268 12923
a -2375 13942 a
  {
 -2375 13942 a -5018 14271 a Fa(Lageru)n(n)n(g)-2375
13942 y
  } 0/Place PSfrag
 -2375 13942 a -1897 15676 a
  {
 -1897 15676 a -4061
16134 a Fa(An)g(trieb)-1897 15676 y
  } 1/Place PSfrag
 -1897 15676 a 268
17281 a
  {
 268 17281 a -7461 17739 a Fa(S)n(c)i(h)n(leifsc)g(h)n(eib)34
b(e)268 17281 y
  } 2/Place PSfrag
 268 17281 a eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
